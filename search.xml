<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Git 教程</title>
      <link href="/2019/02/14/Git-%E6%95%99%E7%A8%8B/"/>
      <url>/2019/02/14/Git-%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="一、Git介绍"><a href="#一、Git介绍" class="headerlink" title="一、Git介绍"></a>一、Git介绍</h3><p>Git是目前世界上最先进的分布式版本控制系统。</p><h4 id="1-1-集中式-VS-分布式"><a href="#1-1-集中式-VS-分布式" class="headerlink" title="1.1 集中式 VS 分布式"></a>1.1 集中式 VS 分布式</h4><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p><p><strong>集中式版本控制系统</strong>：版本库是集中存放在中央服务器，程序员首先需要从中央服务器获取最新版本，然后开始干活，干完活，再把自己的活推给中央服务器。</p><p><strong>分布式版本控制系统</strong>：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候不需要联网。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，而集中式版本控制系统的中央服务器要是出了问题，所有人都没法正常工作了。</p><h4 id="1-2-Git的安装"><a href="#1-2-Git的安装" class="headerlink" title="1.2 Git的安装"></a>1.2 Git的安装</h4><h5 id="1-2-1-Linux上安装Git"><a href="#1-2-1-Linux上安装Git" class="headerlink" title="1.2.1 Linux上安装Git"></a>1.2.1 Linux上安装Git</h5><p>如果是Debian或Ubuntu Linux，通过命令 sudo apt-get install git 可以直接完Git的安装。</p><p>如果是其他Linux版本，可以直接通过源码安装，先从Git官网下载源码，然后解压，一次键入：./config，make，sudo make install这几个命令安装即可。</p><h5 id="1-2-2-Windows上安装Git"><a href="#1-2-2-Windows上安装Git" class="headerlink" title="1.2.2 Windows上安装Git"></a>1.2.2 Windows上安装Git</h5><p>从Git官网直接下载安装程序，然后按默认选项安装即可。</p><p>安装完成后，需要最后一步设置，在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>git config 命令的 global 参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h4 id="1-3-创建版本库"><a href="#1-3-创建版本库" class="headerlink" title="1.3 创建版本库"></a>1.3 创建版本库</h4><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p><strong>第一步</strong>：选择一个合适的地方，创建一个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：通过 git init 命令把这个目录变成Git可以管理的仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="1-4-把文件添加到版本库"><a href="#1-4-把文件添加到版本库" class="headerlink" title="1.4 把文件添加到版本库"></a>1.4 把文件添加到版本库</h4><p>我们在learngit目录或子目录下新建一个 readme.txt 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>：用命令 git add 告诉Git，把文件添加Git仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：用命令 git commit 告诉Git，把文件提交到仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure><p>-m 后面的输入是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="二、时光机穿梭"><a href="#二、时光机穿梭" class="headerlink" title="二、时光机穿梭"></a>二、时光机穿梭</h3><p>上一章节我们成功地添加并提交了一个 readme.txt 文件，现在我们修改文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行 <strong>git status</strong> 命令查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>git status 命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p><p>而通过 <strong>git diff</strong> 命令可以查看文件的修改内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index d8036c1..013b5bc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改文件和提交新文件是一样的两步。 </p><h4 id="2-1-版本回退"><a href="#2-1-版本回退" class="headerlink" title="2.1 版本回退"></a>2.1 版本回退</h4><p>通过 <strong>git log</strong> 命令可以查看文件提交的历史记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 023ddd630b4bef98b7a71d21c9d2e28d28460d7a (HEAD -&gt; master)</span><br><span class="line">Author: lilacflower &lt;511811776@qq.com&gt;</span><br><span class="line">Date:   Tue Jan 22 11:24:41 2019 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit 00cb7386e7ce80b44e77a9f20c1ac5949f1f090e</span><br><span class="line">Author: lilacflower &lt;511811776@qq.com&gt;</span><br><span class="line">Date:   Tue Jan 22 11:15:34 2019 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>现在我们把当前版本 add distributed 回退到上一个版本 wrote a readme file，可以使用 <strong>git reset</strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 00cb738 wrote a readme file</span><br></pre></td></tr></table></figure><p>在 Git 中，用 <strong>HEAD</strong> 表示当前版本，上一个版本就是 <strong>HEAD^</strong>，上上一个版本就是<strong>HEAD^^</strong>，当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 <strong>HEAD~100</strong>。 </p><h5 id="回退到指定的某个版本："><a href="#回退到指定的某个版本：" class="headerlink" title="回退到指定的某个版本："></a>回退到指定的某个版本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 023ddd6</span><br><span class="line">HEAD is now at 023ddd6 add distributed</span><br></pre></td></tr></table></figure><p>其中 023ddd6 是指版本号，版本号没必要写全，前几位就可以了，Git会自动去找，当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>如果忘记版本号，可以通过 <strong>git reflog</strong> 用来查看每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">023ddd6 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 023ddd6</span><br><span class="line">00cb738 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">023ddd6 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">00cb738 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><h4 id="2-2-工作区和暂存区"><a href="#2-2-工作区和暂存区" class="headerlink" title="2.2 工作区和暂存区"></a>2.2 工作区和暂存区</h4><p><strong>工作区</strong>：之前创建的 learngit 文件夹就是一个工作区。</p><p><strong>暂存区</strong>：工作区有一个隐藏目录 .git ，这个不算工作区，而是 Git 的版本库。版本库里存放了很多东西，其中最重要的称为 <strong>stage</strong> （或者叫 index）的暂存区，还有 Git 为我们自己创建的第一个分支 master，以及指向 <strong>master</strong> 的一个指针 <strong>HEAD</strong>。</p><p>前面讲的把文件往版本库添加是分两步进行的，简单理解为，需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。</p><h4 id="2-3-管理修改"><a href="#2-3-管理修改" class="headerlink" title="2.3 管理修改"></a>2.3 管理修改</h4><p>Git跟踪和管理的是修改，而非文件，<strong>git add</strong> 是将修改放入暂存区，<strong>git commit</strong> 只负责将暂存区的修改提交。</p><h4 id="2-4-撤销修改"><a href="#2-4-撤销修改" class="headerlink" title="2.4 撤销修改"></a>2.4 撤销修改</h4><p><strong>场景1</strong>：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- file</span><br></pre></td></tr></table></figure><p><strong>场景2</strong>：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD file</span><br><span class="line">$ git checkout -- file</span><br></pre></td></tr></table></figure><p><strong>场景3</strong>：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h4 id="2-5-删除文件"><a href="#2-5-删除文件" class="headerlink" title="2.5 删除文件"></a>2.5 删除文件</h4><p>从版本库中删除文件也需要执行两个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm file</span><br><span class="line">$ git commit -m &quot;remove file&quot;</span><br></pre></td></tr></table></figure><p>如果删错了，可以从版本库中把误删的文件恢复到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- file</span><br></pre></td></tr></table></figure><h3 id="三、远程仓库"><a href="#三、远程仓库" class="headerlink" title="三、远程仓库"></a>三、远程仓库</h3><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上，实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交，<strong>Github</strong> 应运而生，顾名思义，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>由于本地 Git 仓库和 Github 仓库之间的传输是通过SSH加密的，所以需要按照以下步骤设置：</p><p><strong>第一步</strong>：创建 SSH Key，首先在用户主目录下查看有无 .ssh 目录，如果有，再看看这个目录下有无 id_rsa 和 id_rsa.pub 这两个文件，如果有了，可以直接进行下一步，如果没有，打开 Git Bash （Windows下），创建 SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。</p><p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是SSH Key的秘钥对， id_rsa 是私钥，不能泄露出去， id_rsa.pub 是公钥。</p><p><strong>第二步</strong>：登陆GitHub，打开“Settings”，然后点击“SSH and GPG Keys”，点击“New SSH Key”，填上任意的 Title ，在 Key 文本框里粘贴 id_rsa.pub 的文件内容，最后点击 Add SSH key：</p><p><img src="E:/blog/learning/img/git_1.png" alt="实例1"></p><h4 id="3-1-添加远程库"><a href="#3-1-添加远程库" class="headerlink" title="3.1 添加远程库"></a>3.1 添加远程库</h4><p>本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><p><strong>第一步</strong>：登录 Github ，然后找到“Greate a new repository”，创建一个新的仓库：</p><p><img src="E:/blog/learning/img/git_2.png" alt="实例1"></p><p>Git 仓库生成后，我们根据 Github 的提示，在本地的 learngit 仓库下执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:gitname/learngit.git</span><br></pre></td></tr></table></figure><p>把上面的 gitname 替换成你自己的 Github 账户名，添加后，远程库的名字就是 origin ，这是 Git 默认的叫法，也可以改成别的。</p><p><strong>第二步</strong>：目前 Github 上的这个 learngit 远程库还是空的，把本地库的所有内容推送到远程库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用 git push 命令，实际上是把当前分支 master 推送到远程。</p><p>-u 参数表示，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>之后的本地修改提交操作，就可以通过如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h4 id="3-2-从远程库克隆"><a href="#3-2-从远程库克隆" class="headerlink" title="3.2 从远程库克隆"></a>3.2 从远程库克隆</h4><p>现在，假设已经存在远程库 learngit ，下面通过以下命令从这个远程库克隆到本地库来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:gitname/learngit.git</span><br></pre></td></tr></table></figure><p>上面的 gitname 替换成你自己的 Github 账户名，这里采用的 ssh 协议，也可以采用 https 等其他协议。</p><h3 id="四、分支管理"><a href="#四、分支管理" class="headerlink" title="四、分支管理"></a>四、分支管理</h3><p>可以创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，也不会影响别人工作。</p><h4 id="4-1-创建和合并分支"><a href="#4-1-创建和合并分支" class="headerlink" title="4.1 创建和合并分支"></a>4.1 创建和合并分支</h4><p>在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 <strong>master</strong> 分支。<strong>HEAD</strong> 严格来说不是指向提交，而是指向 master ，master 才是指向提交的，所以，HEAD 指向的就是当前分支。</p><p><strong>第一步</strong>：创建 dev 分支，并切换到 dev 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p><strong>git checkout</strong> 命令加上 -b 参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：使用 <strong>git branch</strong> 命令查看当前分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><strong>git branch</strong> 命令会列出所有分支，当前分支前面会标一个 * 号，然后我们可以在 dev 分支上正常提交。</p><p>当 dev 分支的工作完成，我们可以切回到 master 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：将 dev 分支的工作成果合并到 master 分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure><p><strong>git merge</strong> 命令用于合并指定分支到当前分支。</p><p>合并完成后，可以删除 dev 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 023ddd6).</span><br></pre></td></tr></table></figure><h4 id="4-2-解决冲突"><a href="#4-2-解决冲突" class="headerlink" title="4.2 解决冲突"></a>4.2 解决冲突</h4><p>准备新的分支 feature ，修改 readme.txt 文件并提交，切换到 master 分支，再修改 readme.txt 文件并提交，这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，这种合并就可能会造成冲突。必须手动解决冲突后再提交，<strong>git status</strong> 可以告诉我们发生冲突的文件，我们修改 readme.txt 文件后，再保存提交。</p><p>使用带参数的 <strong>git log</strong> 可以看到分支的合并情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>最后，删除 feature 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature</span><br></pre></td></tr></table></figure><h4 id="4-3-分支管理策略"><a href="#4-3-分支管理策略" class="headerlink" title="4.3 分支管理策略"></a>4.3 分支管理策略</h4><p>通常，合并分支时，Git会用 <strong>Fast forward</strong> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用 Fast forward 模式，Git就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。</p><p>禁用 <strong>Fast forward</strong> 下的分支合并如下（请注意 –no-ff 参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 的描述写进去。</p><p><strong>分支策略</strong></p><ul><li>master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活</li><li>干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如1.0版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布1.0版本</li><li>每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了</li></ul><h4 id="4-4-Bug分支"><a href="#4-4-Bug分支" class="headerlink" title="4.4 Bug分支"></a>4.4 Bug分支</h4><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的 bug 的任务时，很自然地，你想创建一个分支 issue-101 来修复它，但是，当前正在 dev 上进行的工作还没法提交， 这里 Git 提供了一个 stash 功能，将当前工作“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p>现在，用 git status 查看工作区，就是干净的（除了没有被Git管理的文件），因此可以放心地创建分支来修复 bug，然后在需要修复 bug 的分支上创建临时分支，这里是在 master 分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git checkout -b issue-101</span><br></pre></td></tr></table></figure><p>修复完成后，进行提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br></pre></td></tr></table></figure><p>然后切换到 master 分支，并完成合并，最后删除 issue-101 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">$ git branch -d issue-101</span><br></pre></td></tr></table></figure><p>现在回到 dev 分支上继续干活，并用 git stash list 命令查看之前的工作现场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>然后进行工作现场的恢复，现在提供两种恢复方案：</p><ul><li><p>用 git stash apply 恢复，然后用 git stash drop 删除 stash的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure></li><li><p>直接用 git stash pop 命令恢复，恢复的同时删除 stash 的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure></li></ul><p>你可以多次 stash ，恢复的时候，先用 git stash list 命令查看，然后恢复指定的stash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-Feature分支"><a href="#4-5-Feature分支" class="headerlink" title="4.5 Feature分支"></a>4.5 Feature分支</h4><p>每添加一个新功能，最好新建一个 feature-test 分支，在上面开发，完成后，合并，最后删除该 feature-test 分支。</p><p>首先，新建分支并切换到该分支，开发完成后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-test</span><br><span class="line">$ git add test.java</span><br><span class="line">$ git commit -m &quot;add feature test&quot;</span><br></pre></td></tr></table></figure><p>切回到 dev 分支并准备合并前，接到通知，功能取消，现在需要删除 feature-test 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-test</span><br><span class="line">error: The branch &apos;feature-test&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-test&apos;.</span><br></pre></td></tr></table></figure><p>删除失败，并提示 feature-test 分支还没有被合并，如果删除，将丢失掉修改，如果需要强行删除，需要大写的 -D参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-test</span><br></pre></td></tr></table></figure><h4 id="4-6-多人协作"><a href="#4-6-多人协作" class="headerlink" title="4.6 多人协作"></a>4.6 多人协作</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的 <strong>master</strong> 分支和远程的 <strong>master</strong> 分支对应起来了，并且远程仓库的默认名称是 <strong>origin</strong>。</p><p>要查看远程库的信息，用 <strong>git remote</strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用 <strong>git remote -v</strong> 显示更详细的信息。</p><h5 id="4-6-1-推送分支"><a href="#4-6-1-推送分支" class="headerlink" title="4.6.1 推送分支"></a>4.6.1 推送分支</h5><p>推送分支，就是把该分支上的所有本地提交推送到远程库，下面以 <strong>master</strong> 分支为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><strong>master</strong> 分支是主分支，因此要时刻与远程同步</li><li><strong>dev</strong> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li><strong>bug</strong> 分支只用于在本地修复 <strong>bug</strong> ，就没必要推到远程了，除非老板要看看你每周到底修复了几个 bug</li><li><strong>feature</strong> 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</li></ul><h5 id="4-6-2-抓取分支"><a href="#4-6-2-抓取分支" class="headerlink" title="4.6.2 抓取分支"></a>4.6.2 抓取分支</h5><p>从远程库 <strong>clone</strong> 时，默认情况下只能看到本地的 <strong>master</strong> 分支，如果需要在 <strong>dev</strong> 分支上开发，就必须创建远程 <strong>origin</strong> 仓库的 <strong>dev</strong> 分支到本地，可以通过以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在可以继续在 <strong>dev</strong> 分支上修改，然后把 <strong>dev</strong> 分支推送到远程的 <strong>dev</strong> 分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;add readme&quot;</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>如果出现推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，先用 <strong>git pull</strong> 把最新的提交从 <strong>origin/dev</strong> 抓下来，在本地合并，解决冲突，再推送。</p><p>第一次 <strong>git pull</strong> 之前需要指定本地的 <strong>dev</strong> 分支与远程的 <strong>origin/dev</strong> 分支的链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>然后 git pull ，但是远程 dev 分支与本地的 dev 分支合并发生冲突，需要自己手动解决冲突，解决后，提交并推送到远程库。</p><p>因此，多人协作的工作模式总结如下：</p><ol><li>首先，可以试图用 <strong>git push origin <branch-name></branch-name></strong> 推送自己的修改</li><li>如果推送失败，则因为远程分支比你的本地分支更新，要先用 <strong>git pull</strong> 试图合并</li><li>如果合并有冲突，则解决冲突，并在本地提交</li><li>没有冲突或者解决掉冲突后，再用 <strong>git push origin <branch-name></branch-name></strong> 推送就能成功</li></ol><p>如果 <strong>git pull</strong> 提示 <strong>no tracking information</strong>，则说明本地分支和远程分支的链接关系没有创建，用命令 <strong>git branch –set-upstream-to <branch-name> origin/<branch-name></branch-name></branch-name></strong> 。</p><h3 id="五、标签管理"><a href="#五、标签管理" class="headerlink" title="五、标签管理"></a>五、标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签 <strong>tag</strong> ，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><h4 id="5-1-创建标签"><a href="#5-1-创建标签" class="headerlink" title="5.1 创建标签"></a>5.1 创建标签</h4><p><strong>第一步</strong>：切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：打一个新标签，并查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的 commit 上的，有时候对历史的提交打标签，这时候怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">023ddd6 (HEAD -&gt; master) add distributed</span><br><span class="line">00cb738 wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说这次要对 wrote a readme file 的提交打标签，它对应的 commit id 是 00cb738 ，键入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 00cb738</span><br></pre></td></tr></table></figure><p>可以通过 <strong>git show</strong> 查看标签信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br></pre></td></tr></table></figure><p>可以创建带有说明的标签，用 <strong>-a</strong> 指定标签名， <strong>-m</strong> 指定说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 -m &quot;version 0.9 released&quot; 00cb738</span><br></pre></td></tr></table></figure><h4 id="5-2-操作标签"><a href="#5-2-操作标签" class="headerlink" title="5.2 操作标签"></a>5.2 操作标签</h4><h5 id="5-2-1-删除标签"><a href="#5-2-1-删除标签" class="headerlink" title="5.2.1 删除标签"></a>5.2.1 删除标签</h5><p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除后再从远程删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">$ git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure><h5 id="5-2-2-推送标签"><a href="#5-2-2-推送标签" class="headerlink" title="5.2.2 推送标签"></a>5.2.2 推送标签</h5><p>要推送某个标签到远程，使用命令 <strong>git push origin <tagname></tagname></strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 协同开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java并发之cas无锁</title>
      <link href="/2019/01/18/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E6%97%A0%E9%94%81/"/>
      <url>/2019/01/18/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E6%97%A0%E9%94%81/</url>
      <content type="html"><![CDATA[<p>本文主要从无锁的概念、CAS简介、指针类Unsafe以及原子操作类Atomic系列四个部分对Java无锁机制做一个讲解。</p><h3 id="一、无锁的概念"><a href="#一、无锁的概念" class="headerlink" title="一、无锁的概念"></a>一、无锁的概念</h3><p>加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键。</p><h3 id="二、CAS简介"><a href="#二、CAS简介" class="headerlink" title="二、CAS简介"></a>二、CAS简介</h3><p>CAS的全称是Compare And Swap，即比较交换。</p><p>其算法核心思想为执行函数：CAS(V, E, N)</p><p>其包含的三个参数：</p><ul><li>V表示要更新的变量值</li><li>E表示预期值</li><li>N表示新值</li></ul><p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量重新尝试修改该变量，也可以放弃操作。</p><h4 id="2-1-CPU指令对CAS的支持"><a href="#2-1-CPU指令对CAS的支持" class="headerlink" title="2.1 CPU指令对CAS的支持"></a>2.1 CPU指令对CAS的支持</h4><p>假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统<strong>原语</strong>，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h3 id="三、指针类Unsafe"><a href="#三、指针类Unsafe" class="headerlink" title="三、指针类Unsafe"></a>三、指针类Unsafe</h3><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应的任务，关于Unsafe类的主要功能点如下：</p><ul><li><p>内存管理，Unsafe类中直接操作内存的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//分配指定大小的内存</span><br><span class="line">public native long allocateMemory(long bytes);</span><br><span class="line"></span><br><span class="line">//根据给定的内存地址address重新分配指定大小的内存</span><br><span class="line">public native long reallocateMemory(long address, long bytes);</span><br><span class="line"></span><br><span class="line">//释放allocateMemory和reallocateMemory申请的内存</span><br><span class="line">public native void freeMemory(long address);</span><br><span class="line"></span><br><span class="line">//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值</span><br><span class="line">public native void setMemory(Object o, long offset, long bytes, byte value);</span><br><span class="line"></span><br><span class="line">//设置和获取指定内存地址的值</span><br><span class="line">public native void putAddress(long address, long x);</span><br><span class="line">public native long getAddress(long address);</span><br><span class="line"></span><br><span class="line">//设置和获取指定内存地址的long值</span><br><span class="line">public native void putLong(long address, long x);</span><br><span class="line">public native long getLong(long address);</span><br><span class="line"></span><br><span class="line">//设置和获取指定内存的byte值</span><br><span class="line">public native void putByte(long address, byte x);</span><br><span class="line">public native byte getByte(long address);</span><br><span class="line">//其他基本数据类型(long, char, float, double, short等)的操作与putByte及getByte相同</span><br><span class="line"></span><br><span class="line">//获取操作系统的内存页大小</span><br><span class="line">public native int pageSize();</span><br></pre></td></tr></table></figure></li><li><p>提供实例对象新途径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//传入一个对象的class属性并创建该实例对象，但不会调用构造方法</span><br><span class="line">public native Object allocateInstance(Class cls) throws InstantiationException;</span><br></pre></td></tr></table></figure></li><li><p>类和实例对象以及变量操作的主要方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//获取字段f在实例对象中的偏移量</span><br><span class="line">public native long objectFieldOffset(Field f);</span><br><span class="line"></span><br><span class="line">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span><br><span class="line">public native long staticFieldOffset(Field f);</span><br><span class="line"></span><br><span class="line">//返回值是f.getDeclaringClass()</span><br><span class="line">public native Object staticFieldBase(Field f);</span><br><span class="line"></span><br><span class="line">//获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量的内存地址</span><br><span class="line">//通过偏移量便可得到该对象的变量，进行各种操作</span><br><span class="line">public native int getInt(Object o, long offset);</span><br><span class="line"></span><br><span class="line">//设置指定对象上偏移量的int值</span><br><span class="line">public native void putInt(Object o, long offset, int x);</span><br><span class="line">//其他基本数据类型(long, char, byte, float, double)的操作与getInt及putInt相同</span><br><span class="line"></span><br><span class="line">//设置和获取指定对象偏移量上的引用类型的值</span><br><span class="line">public native Object getObject(Object o, long offset);</span><br><span class="line">public native void putObject(Object o, long offset, Object x);</span><br><span class="line"></span><br><span class="line">//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span><br><span class="line">public native void  putIntVolatile(Object o, long offset, int x);</span><br><span class="line"></span><br><span class="line">//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值</span><br><span class="line">public native int getIntVolatile(Object o, long offset);</span><br><span class="line">//其他基本数据类型(long, char, byte, float, double)的操作与putIntVolatile及getIntVolatile相同，引用类型putObjectVolatile也一样</span><br><span class="line"></span><br><span class="line">//与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span><br><span class="line">public native void putOrderedInt(Object o,long offset,int x);</span><br></pre></td></tr></table></figure></li><li><p>数组相关操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取数组第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class arrayClass);</span><br><span class="line"></span><br><span class="line">//数组中一个元素占据的内存空间，arrayBaseOffset与arrayIndexScale配合使用，可定位数组中每个元素在内存中的位置</span><br><span class="line">public native int arrayIndexScale(Class arrayClass);</span><br></pre></td></tr></table></figure></li><li><p>CAS相关操作</p><p>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现，即在稍后讲解Atomic系列内部方法是基于下述方法的实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置和获取该字段的值，expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作</span><br><span class="line">public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);                                                                                                  </span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x);</span><br></pre></td></tr></table></figure><p>以下是Unsafe类中JDK1.8新增的几个方法，它们的实现基于上述的CAS方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//给定对象o，根据获取内存偏移量指向的字段，将其增加delta，这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取内存中最新值</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">        //通过CAS操作</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法作用同上，这里操作的long类型数据</span><br><span class="line">public final long getAndAddLong(Object o, long offset, long delta) &#123;</span><br><span class="line">    long v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span><br><span class="line">public final int getAndSetInt(Object o, long offset, int newValue) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法作用同上，这里操作的是long类型</span><br><span class="line">public final long getAndSetLong(Object o, long offset, long newValue) &#123;</span><br><span class="line">    long v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法作用同上，这里操作的是引用类型数据</span><br><span class="line">public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">    Object v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getObjectVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程挂起与恢复</p><p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现，unpark可以终止一个挂起的线程，使其恢复正常。Java将线程的挂起操作封装在 LockSupport类中，LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()和Unsafe.unpark()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件的出现</span><br><span class="line">public native void park(boolean isAbsolute, long time);</span><br><span class="line"></span><br><span class="line">//终止挂起的线程，恢复正常，java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法</span><br><span class="line">public native void unpark(Object thread);</span><br></pre></td></tr></table></figure></li><li><p>内存屏障</p><p>主要包括了loadFence、storeFence、fullFence等方法，这些方法是在Java 8新引入的，用于定义内存屏障，避免指令重排序，与Java内存模型相关，这里不做展开。</p></li><li><p>其他操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//获取持有锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">//释放锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">//尝试获取锁，已不建议使用</span><br><span class="line">@Deprecated</span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">//获取本机内存的页数，这个值永远都是2的幂次方</span><br><span class="line">public native int pageSize();  </span><br><span class="line"></span><br><span class="line">//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来调用这个类  </span><br><span class="line">public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);  </span><br><span class="line"></span><br><span class="line">//加载一个匿名类</span><br><span class="line">public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);</span><br><span class="line"></span><br><span class="line">//判断是否需要加载一个类</span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; c);</span><br><span class="line"></span><br><span class="line">//确保类一定被加载 </span><br><span class="line">public native void ensureClassInitialized(Class&lt;?&gt; c);</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、原子操作类Atomic系列"><a href="#四、原子操作类Atomic系列" class="headerlink" title="四、原子操作类Atomic系列"></a>四、原子操作类Atomic系列</h3><p>并发包中的原子操作类(Atomic系列)即是CAS在Java中的应用，从JDK 1.5开始提供了java.util.concurrent.atomic包，在该包中提供了许多基于CAS实现的原子操作类，用法方便，性能高效，主要分以下4种类型</p><h4 id="4-1-原子更新基本类型"><a href="#4-1-原子更新基本类型" class="headerlink" title="4.1 原子更新基本类型"></a>4.1 原子更新基本类型</h4><p>原子更新基本类型主要包括3个类：</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等。</p><p>AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe类中的getAndAddInt()方法</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">int v;</span><br><span class="line">do &#123;</span><br><span class="line">v = getIntVolatile(o, offset);</span><br><span class="line">&#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码分析是基于JDK1.8的，可看出getAndAddInt()方法是通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt()方法，是一个CAS操作方法。</p><h4 id="4-2-原子更新引用类型"><a href="#4-2-原子更新引用类型" class="headerlink" title="4.2 原子更新引用类型"></a>4.2 原子更新引用类型</h4><p>原子更新引用类型，这里主要分析一下AtomicReference原子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">(AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内部变量value，Unsafe类通过valueOffset内存偏移量即可获取该变量</span><br><span class="line">private volatile V value;</span><br><span class="line"></span><br><span class="line">//CAS方法，间接调用unsafe.compareAndSwapObject()方法，它是一个实现了CAS操作的native方法</span><br><span class="line">public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置并获取旧值</span><br><span class="line">public final V getAndSet(V newValue) &#123;</span><br><span class="line">return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line">//省略其他代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unsafe类中的getAndSetObject方法，实际调用还是CAS操作</span><br><span class="line">public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">Object v;</span><br><span class="line">do &#123;</span><br><span class="line">v = getObjectVolatile(o, offset);</span><br><span class="line">&#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码看来，AtomicReference与AtomicInteger的实现原理基本是一样的，最终执行的还是Unsafe类。</p><h4 id="4-3-原子更新数组"><a href="#4-3-原子更新数组" class="headerlink" title="4.3 原子更新数组"></a>4.3 原子更新数组</h4><p>原子更新数组指的是通过原子的方式更新数组里的某个元素，主要有以下3个类：</p><ul><li>AtomicIntegerArray：原子更新整数数组里的元素</li><li>AtomicLongArray：原子更新长整数数组里的元素</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素</li></ul><p>这里以AtomicIntegerArray为例进行分析，其余两个使用方式和实现原理基本一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</span><br><span class="line">//获取unsafe类的实例对象</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">//获取数组的第一个元素内存起始地址</span><br><span class="line">private static final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line"></span><br><span class="line">private static final int shift;</span><br><span class="line">//内部数组</span><br><span class="line">private final int[] array;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">//获取数组中一个元素占据的内存空间</span><br><span class="line">int scale = unsafe.arrayIndexScale(int[].class);</span><br><span class="line">//判断是否为2的次幂，一般为2的次幂否则抛异常</span><br><span class="line">if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private long checkedByteOffset(int i) &#123;</span><br><span class="line">if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line">return byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算数组中每个元素的的内存地址</span><br><span class="line">private static long byteOffset(int i) &#123;</span><br><span class="line">return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line">//省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arrayBaseOffset()方法可以获取数组的第一个元素起始地址，而arrayIndexScale()方法可以获取每个数组元素占用的内存空间，由于这里是int类型，而Java中一个int类型占用4个字节，也就是scale的值为4，那么如何根据数组下标值计算每个元素的内存地址呢？显然应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个数组元素的内存地址 = 起始地址 + 元素下标 * 每个元素所占用的内存空间</span><br></pre></td></tr></table></figure><h4 id="4-4-原子更新属性"><a href="#4-4-原子更新属性" class="headerlink" title="4.4 原子更新属性"></a>4.4 原子更新属性</h4><p>如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类Atomic并发包提供了以下三个类：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul><p>原子更新器的使用必须满足以下几个条件：</p><ul><li>操作的字段不能是static类型</li><li>操作的字段不能是final类型的，因为final根本没法修改</li><li>字段必须是volatile修饰的，也就是数据本身是读一致的</li><li>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作则不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性</li></ul><p>下面简单了解一下AtomicIntegerFieldUpdater的实现原理，实际就是Unsafe与反射相结合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> private static class AtomicIntegerFieldUpdaterImpl&lt;T&gt;</span><br><span class="line">            extends AtomicIntegerFieldUpdater&lt;T&gt; &#123;</span><br><span class="line">        private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        private final long offset;//内存偏移量</span><br><span class="line">        private final Class&lt;T&gt; tclass;</span><br><span class="line">        private final Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(final Class&lt;T&gt; tclass,</span><br><span class="line">                                      final String fieldName,</span><br><span class="line">                                      final Class&lt;?&gt; caller) &#123;</span><br><span class="line">            final Field field;//要修改的字段</span><br><span class="line">            final int modifiers;//字段修饰符</span><br><span class="line">            try &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                            return tclass.getDeclaredField(fieldName);//反射获取字段对象</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                //获取字段修饰符</span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">            //对字段的访问权限进行检查,不在访问范围内抛异常</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, null, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">              sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw new RuntimeException(pae.getException());</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">            //判断是否为int类型</span><br><span class="line">            if (fieldt != int.class)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be integer type&quot;);</span><br><span class="line">            //判断是否被volatile修饰</span><br><span class="line">            if (!Modifier.isVolatile(modifiers))</span><br><span class="line">                throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line">            this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : null;</span><br><span class="line">            this.tclass = tclass;</span><br><span class="line">            //获取该字段的在对象内存的偏移量，通过内存偏移量可以获取或者修改该字段的值</span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-ABA问题及其解决方案"><a href="#4-5-ABA问题及其解决方案" class="headerlink" title="4.5 ABA问题及其解决方案"></a>4.5 ABA问题及其解决方案</h4><p>CAS的ABA问题：当第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值又恢复为旧值，这样的话，我们就无法正确判断这个变量是否已被修改过，一般情况下这种情况发生的概率比较小，但是在某些场景下还是需要防止的，Java中提供了如下两个原子类来解决ABA问题：</p><ul><li><p>AtomicStampedReference</p><p>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功。</p></li><li><p>AtomicMarkableReference</p><p>与AtomicStampedReference不同的是，AtomicMarkableReference维护的是一个boolean值的标识，也就是说可以置于true和false两种切换状态，但是这种方式并不能完全防止ABA问题的发生，只能减少ABA问题发生的概率。</p></li></ul><p>如果要完全杜绝ABA问题的发生，我们应该使用AtomicStampedReference原子类更新对象，而对于AtomicMarkableReference来说只能减少ABA问题的发生概率，并不能杜绝。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAS </tag>
            
            <tag> 无锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制详解</title>
      <link href="/2018/12/24/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/12/24/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文将通过以下三个部分对反射进行一个讲解，包括反射的定义、反射的作用以及反射的应用场景：</p><h1 id="一、反射的定义"><a href="#一、反射的定义" class="headerlink" title="一、反射的定义"></a>一、反射的定义</h1><p>在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有方法和属性)。这种动态获取的信息以及动态调用对象的方法的功能就称为Java的反射机制。通俗点讲，通过反射，该类对我们来说是完全透明的，可以获取任何想要的东西。</p><p>要使用反射机制，就必须先获取到该类的字节码文件对象（.class），通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息（属性，方法，类名，父类名，实现的接口等等），每一个类对应着一个字节码文件也就对应着一个Class类型的对象，也就是字节码文件对象。</p><p>获取字节码文件对象的三种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//通过Class类中的方法forName，直接获取到字节码文件对象，此时该类还是源文件阶段，并没有变为字节码文件</span><br><span class="line">1. Class clz1 = Class.forName(&quot;全限定类名&quot;);</span><br><span class="line">//当类被加载成.class文件时，此时User类变成了.class，在获取该字节码文件对象，该类处于字节码文件阶段</span><br><span class="line">2. Class clz2 = User.class;</span><br><span class="line">//通过类的实例获取该类的字节码文件对象，该类处于对象创建阶段</span><br><span class="line">3. User user = new User();</span><br><span class="line">   Class clz3 = user.getClass();</span><br></pre></td></tr></table></figure><h1 id="二、反射的作用"><a href="#二、反射的作用" class="headerlink" title="二、反射的作用"></a>二、反射的作用</h1><h3 id="2-1-通过字节码对象创建实例对象"><a href="#2-1-通过字节码对象创建实例对象" class="headerlink" title="2.1 通过字节码对象创建实例对象"></a>2.1 通过字节码对象创建实例对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Person类还未加载，在源文件阶段就获取其字节码文件对象</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//创建Person实例，这里通过无参构造来创建对象</span><br><span class="line">Person person = (Person) clz1.newInstance();</span><br><span class="line">//通过person对象可以获取我们想要的信息</span><br></pre></td></tr></table></figure><h3 id="2-2-获取构造器方法（通过有参构造创建实例）"><a href="#2-2-获取构造器方法（通过有参构造创建实例）" class="headerlink" title="2.2 获取构造器方法（通过有参构造创建实例）"></a>2.2 获取构造器方法（通过有参构造创建实例）</h3><p>获取指定构造器方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取有参构造器，parameterTypes：表示参数列表</span><br><span class="line">Constructor constructor = clz1.getConstructor(int.class, String.class);</span><br><span class="line">//通过构造器来实例化对象</span><br><span class="line">Person person = (Person) constructor.newInstance(1, &quot;小刚&quot;);</span><br></pre></td></tr></table></figure><p>获取全部构造器方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取所有构造方法</span><br><span class="line">Constructor[] constructors = clz1.getConstructors();</span><br><span class="line">//遍历所有构造方法</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">//获取每个构造函数中的参数类型字节码对象</span><br><span class="line">    Class[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line">    for (Class clz : parameterTypes) &#123;</span><br><span class="line">    //获取构造函数中的参数类型</span><br><span class="line">        System.out.print(clz.getName() + &quot;，&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-获取成员变量（Field）"><a href="#2-3-获取成员变量（Field）" class="headerlink" title="2.3 获取成员变量（Field）"></a>2.3 获取成员变量（Field）</h3><p>获取指定成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取实例对象</span><br><span class="line">Person person = (Person) clz1.newInstance();</span><br><span class="line">//可通过clz1.getField(name)获取成员变量，name为指定变量名</span><br><span class="line">//如果该成员变量是私有的，则应使用getDeclaredField(name)</span><br><span class="line">Field idField = clz1.getDeclaredField(&quot;id&quot;);</span><br><span class="line">//因为属性是私有的，获得其属性对象后，需要打开可见权限</span><br><span class="line">idField.setAccessible(true);</span><br><span class="line">//对成员变量进行赋值操作</span><br><span class="line">idField.setInt(person, 1);</span><br><span class="line">//获取成员变量的值，field.get(obj)，其中obj表示该属性对应的实例变量</span><br><span class="line">System.out.print(idField.getInt(person));</span><br></pre></td></tr></table></figure><p>获取全部成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件对象</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取实例对象</span><br><span class="line">Person person = (Person) clz1.newInstance();</span><br><span class="line">person.setId(1);</span><br><span class="line">person.setName(&quot;小刚&quot;);</span><br><span class="line">Field[] fields = clz1.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">    System.out.print(field.get(person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-获取方法（Method）"><a href="#2-4-获取方法（Method）" class="headerlink" title="2.4 获取方法（Method）"></a>2.4 获取方法（Method）</h3><p>获取指定方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件对象</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取实例对象</span><br><span class="line">Person person = (Person) clz1.newInstance();</span><br><span class="line">//clz1.getMethod(name, parameterTypes)，name为方法名，parameterTypes为方法参数类型的Class类型</span><br><span class="line">Method method1 = clz1.getMethod(&quot;read&quot;);</span><br><span class="line">//method.invoke(obj, args)，obj为实例对象，args为参数值，没有则不填</span><br><span class="line">method1.invoke(person);</span><br><span class="line">Method method2 = clz1.getMethod(&quot;sing&quot;, String.class);</span><br><span class="line">method2.invoke(person, &quot;小刚&quot;);</span><br><span class="line">//获取私有方法getDeclaredMethod(name)</span><br><span class="line">Method method3 = clz1.getMethod(&quot;say&quot;);</span><br><span class="line">method3.setAccessible(true);</span><br><span class="line">method3.invoke(person);</span><br></pre></td></tr></table></figure><p>获取全部方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取字节码文件对象</span><br><span class="line">Class clz1 = Class.forName(&quot;reflect.Person&quot;);</span><br><span class="line">//获取实例对象</span><br><span class="line">Person person = (Person) clz1.newInstance();</span><br><span class="line">Method[] methods = clz1.getDeclaredMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">    method.setAccessible(true);</span><br><span class="line">    System.out.print(method.getName());</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    for (Class clz : parameterTypes) &#123;</span><br><span class="line">    //获取方法中的参数类型</span><br><span class="line">        System.out.print(clz.getName() + &quot;，&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-获取类的所有接口"><a href="#2-5-获取类的所有接口" class="headerlink" title="2.5 获取类的所有接口"></a>2.5 获取类的所有接口</h3><p>Class[]    getInterfaces()：确定此对象所表示的类或接口所实现的接口</p><p>返回值：接口的字节码文件对象数组</p><h3 id="2-6-获取指定资源的输入流"><a href="#2-6-获取指定资源的输入流" class="headerlink" title="2.6 获取指定资源的输入流"></a>2.6 获取指定资源的输入流</h3><p>InputStream        getResourceAsStream(String name)</p><p>返回值：一个InputStream对象；如果找不到带有该名称的资源，则返回 null</p><p>参数：所需资源的名称，如果以”/“开始，则绝对资源名为”/“后面的一部分</p><h1 id="三、反射机制的应用实例"><a href="#三、反射机制的应用实例" class="headerlink" title="三、反射机制的应用实例"></a>三、反射机制的应用实例</h1><h3 id="3-1-利用反射，在泛型为int类型的ArrayList中存放String类型对象"><a href="#3-1-利用反射，在泛型为int类型的ArrayList中存放String类型对象" class="headerlink" title="3.1 利用反射，在泛型为int类型的ArrayList中存放String类型对象"></a>3.1 利用反射，在泛型为int类型的ArrayList中存放String类型对象</h3><p>原理：集合中的泛型只在编译期有效，而在运行期，泛型则会失效</p><h3 id="3-2-利用反射，可以减少编写Servlet的个数"><a href="#3-2-利用反射，可以减少编写Servlet的个数" class="headerlink" title="3.2 利用反射，可以减少编写Servlet的个数"></a>3.2 利用反射，可以减少编写Servlet的个数</h3><ol><li>编写一个BaseServlet继承HttpServlet，这是一个通用的BaseServlet</li><li>编写具体实现的方法servlet类</li><li>需要明白servlet的生命周期，也就是service方法，因为是servlet，所以在访问的时候，会经过service方法，而子类中并没有，所以就到父类BaseServlet中找，发现有，然后获取参数即知道了需要调用什么方法，因为方法的编写都在子类中，所以通过反射，获取到子类中对应的方法并运行，其中需要注意的是this这个参数在BaseServlet中的用法</li></ol>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 文件读写（IO/NIO）</title>
      <link href="/2018/12/24/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%88IO-NIO%EF%BC%89/"/>
      <url>/2018/12/24/Java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%88IO-NIO%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>文件读写通常有以下几种方法：</p><ol><li>文件读写（InputStream/OutputStream）</li><li>字符读取（FileReader/FileWriter）</li><li>行读取（BufferedReader/BufferedWriter）</li></ol><p>代码（txt文件读写为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: tugang</span><br><span class="line"> * @Description: 字节流、字符流、缓冲流</span><br><span class="line"> * @Date: Created in 2018年12月24日 下午4:03:00</span><br><span class="line"> * @Modified by: </span><br><span class="line"> */</span><br><span class="line">public class FileOperate &#123;</span><br><span class="line"></span><br><span class="line">private static final String FILE_READ_PATH = &quot;E:/work/readTest.txt&quot;;</span><br><span class="line">private static final String FILE_WRITE_PATH = &quot;E:/work/writeTest.txt&quot;;</span><br><span class="line"></span><br><span class="line">//以字节为单位读写文件内容</span><br><span class="line">public static void readFileByByte(String filePath) &#123;</span><br><span class="line">File file = new File(filePath);</span><br><span class="line">//InputStream: 此抽象类是表示字节输入流的所有类的超类</span><br><span class="line">InputStream ins = null;</span><br><span class="line">OutputStream ous = null;</span><br><span class="line">try &#123;</span><br><span class="line">//FileInputStream: 从文件系统中的某个文件中获得输入字节</span><br><span class="line">ins = new FileInputStream(file);</span><br><span class="line">ous = new FileOutputStream(FILE_WRITE_PATH);</span><br><span class="line">int temp = 0;</span><br><span class="line">//read(): 从输入流中读取数据的下一个字节</span><br><span class="line">while ((temp = ins.read()) != -1) &#123;</span><br><span class="line">ous.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (ins != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ins.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (ous != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ous.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以字符为单位读写文件内容</span><br><span class="line">public static void readFileByCharacter(String filePath) &#123;</span><br><span class="line">File file = new File(filePath);</span><br><span class="line">//FileReader: 用来读取字符文件的便捷类</span><br><span class="line">FileReader reader = null;</span><br><span class="line">FileWriter writer = null;</span><br><span class="line">try &#123;</span><br><span class="line">reader = new FileReader(file);</span><br><span class="line">writer = new FileWriter(FILE_WRITE_PATH);</span><br><span class="line">int temp = 0;</span><br><span class="line">while ((temp = reader.read()) != -1) &#123;</span><br><span class="line">writer.write((char) temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (reader != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (writer != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">writer.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以行为单位读写文件内容</span><br><span class="line">public static void readFileByLine(String filePath) &#123;</span><br><span class="line">File file = new File(filePath);</span><br><span class="line">//BufferedReader: 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取</span><br><span class="line">BufferedReader bufReader = null;</span><br><span class="line">BufferedWriter bufWriter = null;</span><br><span class="line">try &#123;</span><br><span class="line">bufReader = new BufferedReader(new FileReader(file));</span><br><span class="line">bufWriter = new BufferedWriter(new FileWriter(FILE_WRITE_PATH));</span><br><span class="line">String temp = null;</span><br><span class="line">while ((temp = bufReader.readLine()) != null) &#123;</span><br><span class="line">bufWriter.write(temp + &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (bufReader != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">bufReader.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (bufWriter != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">bufWriter.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Java.nio ByteBuffer字节将一个文件输出至另一文件</span><br><span class="line">public static void readFileByByteBuffer(String filePath) &#123;</span><br><span class="line">FileInputStream ins = null;</span><br><span class="line">FileOutputStream ous = null;</span><br><span class="line">try &#123;</span><br><span class="line">//获取源文件和目标文件的输入输出流</span><br><span class="line">ins = new FileInputStream(filePath);</span><br><span class="line">ous = new FileOutputStream(FILE_WRITE_PATH);</span><br><span class="line">FileChannel fcIns = ins.getChannel();</span><br><span class="line">FileChannel fcOus = ous.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">int r = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">//clear方法重设缓冲区，使它可以接受读入的数据</span><br><span class="line">buffer.clear();</span><br><span class="line">//从输入通道中将数据读到缓冲区</span><br><span class="line">r = fcIns.read(buffer);</span><br><span class="line">if (r == -1) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//flip方法让缓冲区可以将新读入的数据写入另一个通道</span><br><span class="line">buffer.flip();</span><br><span class="line">fcOus.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (ins != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ins.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (ous != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ous.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是本文关于Java 文件读写（IO/NIO）三种输入输出流详细代码及总结，希望对大家有所帮助。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> io </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM浅析</title>
      <link href="/2018/12/20/JVM%E6%B5%85%E6%9E%90/"/>
      <url>/2018/12/20/JVM%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本节内容主要从JVM结构、类加载机制、垃圾回收GC原理、JVM内存分配及回收策略、JVM内存泄露和溢出等五个方面展开。</p><h1 id="二、JVM结构"><a href="#二、JVM结构" class="headerlink" title="二、JVM结构"></a>二、JVM结构</h1><p>JVM的内部结构如下图：</p><p><img src="https://img-blog.csdn.net/20170823151822792?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbmdtaW5ncWlqaXF1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="JVM内部结构"></p><ul><li><p>类装载器</p><p>JVM启动，程序开始执行时，负责将class字节码加载到JVM内存区域中</p></li><li><p>执行引擎</p><p>负责执行class文件中包含的字节码指令</p></li><li><p>本地方法库</p><p>主要是调用C或C++实现的本地方法以及返回结果</p></li><li><p>运行时数据区（重点关注）</p><ul><li><p>方法区（Method Area）</p><p>用于存储类结构信息，包括常量池、静态变量、构造函数等</p></li><li><p>堆（Heap）</p><p>存储java实例或者对象的地方，这块是GC的主要区域，方法区和堆是被所有java线程共享的</p></li><li><p>虚拟机栈（VM Stack）</p><p>虚拟机栈总是和线程相关联的，每当创建一个线程时，JVM就会为这个线程创建一个对应的虚拟机栈。在这个虚拟机栈中会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程，所以虚拟机栈是线程私有的</p></li><li><p>程序计数器（Program Counter Register）</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>本地方法栈（Native Method Stack）</p><p>和虚拟机栈的作用差不多，只不过是为JVM所使用的nvtive方法服务的</p></li></ul></li></ul><h1 id="三、JVM类加载机制"><a href="#三、JVM类加载机制" class="headerlink" title="三、JVM类加载机制"></a>三、JVM类加载机制</h1><p>JVM类加载机制主要采用的是双亲委派模型如下图所示：</p><p><img src="https://img-blog.csdn.net/20170823153705547?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbmdtaW5ncWlqaXF1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="类加载器"></p><ul><li><p>启动类加载器（Bootstrap ClassLoader）</p><p>它是最顶层的类加载器，是由C++编写而成，已经内嵌到JVM中了，在JVM启动时会初始化该ClassLoader，它主要用来读取Java的核心类库jre/lib/rt.jar中所有的class文件，如果需要将自己写的类加载器加载请求委派给引导类加载器，那么直接使用null代替即可</p></li><li><p>扩展类加载器（Extension ClassLoader）</p><p>负责加载jre/lib/ext目录中的jar包 </p></li><li><p>应用程序类加载器（Application ClassLoader）</p><p>是类加载器ClassLoader.getSystemClassLoader()方法的返回值，因此称为系统类加载器，负责加载用户路径上指定的类库，一般情况下是默认的类加载器 </p></li><li><p>自定义类加载器（Custom ClassLoader）</p><p>负责加载用户自定义的jar包</p></li></ul><p>以上4种类加载器之间的这种层次关系称为类加载器的双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码 。</p><p>双亲委派的工作流程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派机制的最大优点就是使得java类随着它的类加载器一起具备了一种带有优先级的层次关系。尤其是保证了基础类的统一性，保证了java程序的稳定运行</p><h1 id="四、垃圾回收GC原理"><a href="#四、垃圾回收GC原理" class="headerlink" title="四、垃圾回收GC原理"></a>四、垃圾回收GC原理</h1><p>垃圾回收算法主要采用的是分代收集算法【GC】。 </p><p>GC是根据对象的存活周期的不同将内存划分为几块。一般是把java堆分成新生代和老年代。新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，于是选用复制算法，只需要复制少量存活对象即可完成收集。而老年代中因为对象存活率高、没有额外的空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来回收</p><h1 id="五、JVM内存分配及回收策略"><a href="#五、JVM内存分配及回收策略" class="headerlink" title="五、JVM内存分配及回收策略"></a>五、JVM内存分配及回收策略</h1><p>JVM的内存分配也是和GC保持一致的，具体分配如图：</p><p><img src="https://img-blog.csdn.net/20140101101922203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2luZ29md29ybGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="内存分配"></p><p>具体的回收策略如图：</p><p><img src="https://img-blog.csdn.net/20140101113433906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2luZ29md29ybGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="回收策略"></p><p>策略总结：对象优先在eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代，动态对象进行年龄判定后再分代</p><h1 id="六、JVM内存泄漏和溢出"><a href="#六、JVM内存泄漏和溢出" class="headerlink" title="六、JVM内存泄漏和溢出"></a>六、JVM内存泄漏和溢出</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li><p>内存泄漏</p><p>指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用</p></li><li><p>内存溢出</p><p>指程序运行过程中无法申请到足够的内存而导致的一种错误，内存溢出通常发生于Old段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况</p><p>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素</p><p>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况，出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heapspace”</p></li></ul><h2 id="2-内存泄漏常见的几种场景"><a href="#2-内存泄漏常见的几种场景" class="headerlink" title="2. 内存泄漏常见的几种场景"></a>2. 内存泄漏常见的几种场景</h2><ol><li><p>长生命周期的对象持有短生命周期对象的引用</p><p>这是内存泄露最常见的场景，也是代码设计中经常出现的问题。例如：在全局静态map中缓存局部变量，且没有清空操作，随着时间的推移，这个map会越来越大，造成内存泄露 </p></li><li><p>修改hashset中对象的参数值，且参数是计算哈希值的字段</p><p>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露</p></li><li><p>机器的连接数和关闭时间设置</p><p>长时间开启非常耗费资源的连接，也会造成内存泄露</p></li></ol><h2 id="3-内存溢出的几种情况"><a href="#3-内存溢出的几种情况" class="headerlink" title="3. 内存溢出的几种情况"></a>3. 内存溢出的几种情况</h2><ol><li><p>堆内存溢出（OutOfMemoryError：Java heap space）</p><p>在jvm规范中，堆中的内存是用来生成对象实例和数组的。如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。</p><p>当生成新对象时，内存的申请过程如下：<br>a、jvm先尝试在eden区分配新建对象所需的内存；<br>b、如果内存大小足够，申请结束，否则进行下一步；<br>c、jvm启动youngGC，试图将eden区中不活跃的对象释放掉，释放后若eden空间仍然不足以放入新对象，则试图将部分eden中活跃对象放入survivor区；<br>d、survivor区被用来作为eden及old的中间交换区域，当old区空间足够时，survivor区的对象会被移到old区，否则会被保留在survivor区；<br>e、当old区空间不够时，jvm会在old区进行full GC；<br>f、full GC后，若survivor及old区仍然无法存放从eden复制过来的部分对象，导致jvm无法在eden区为新对象创建内存区域，则出现”out of memory错误”： outOfMemoryError：java heap space</p></li><li><p>方法区内存溢出（OutOfMemoryError：permgem space）</p><p>在jvm规范中，方法区主要存放的是类信息、常量、静态变量等。</p><p>所以如果程序加载的类过多，或者使用反射、cglib等这种动态代理生成类的技术，就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为： outOfMemoryError：permgem space</p></li><li><p>线程栈溢出（java.lang.StackOverflowError）</p><p>线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。<br>一般线程栈溢出是由于递归太深或方法调用层级过多导致的。发生栈溢出的错误信息为：java.lang.StackOverflowError</p></li><li><p>如何解决内存泄漏或溢出问题</p><p>要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的，掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置</p><p>如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</p></li><li><p>如何避免发生内存泄漏或溢出</p><ul><li>尽早释放无用对象的引用</li><li>使用字符串处理，避免使用String，应使用StringBuffer，每一个String对象都得独立占用内存一块区域</li><li>尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收</li><li>避免在循环中创建对象</li><li>开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/11/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/11/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>文件&amp;文件目录操作：<br>cd /file        &emsp;&emsp;进入file目录<br>cd ..            &emsp;&emsp;退出一级目录<br>cd /            &emsp;&emsp;退到根目录<br>pwd        &emsp;&emsp;查看当前的位置路径<br>ls            &emsp;&emsp;查看文件目录中的文件<br>ls -ll            &emsp;&emsp;显示详细信息<br>ls -a            &emsp;&emsp;显示隐藏信息<br>rm -f file        &emsp;&emsp;删除当前目录下的file文件<br>rm -fr dir    &emsp;&emsp;删除dir目录（包含子文件）<br>mkdir file    &emsp;&emsp;新建一个文件夹<br>mkdir file1 file2        &emsp;创建两个文件目录<br>mv source target        &emsp;将文件source重命名为target<br>cp sou tar            &emsp;将文件sou复制到tar<br>cp /root/sou .        &emsp;将root下的sou复制到当前目录<br>cat file        &emsp;&emsp;显示文件内容<br>tac file        &emsp;&emsp;反向查看一个文件内容<br>head -i file    &emsp;&emsp;查看一个文件的前i行<br>tail -i file        &emsp;&emsp;查看一个文件的后i行<br>tail -f file        &emsp;&emsp;查看文件的动态日志<br>tail -f nohup.out        &emsp;weblogic下out的动态日志<br>vi file                &emsp;编辑文件<br>find / -name file        &emsp;从根开始搜索文件和目录<br>find / -user username    &emsp;从根开始搜索属于username的文件和目录</p><p>进程查看操作：<br>ps            &emsp;&emsp;显示当前系统进程<br>ps -ef        &emsp;&emsp;显示系统所有进程<br>ps -ef|grep java        &emsp;&emsp;显示系统java进程<br>ps -ef|grep app        &emsp;&emsp;显示app应用进程名<br>kill -9 i        &emsp;&emsp;杀死编号为i的进程<br>killall -9 i        &emsp;&emsp;对名字包含i的进程杀死<br>top            &emsp;&emsp;显示系统的活跃情况，按CPU资源百分比来分<br>free            &emsp;&emsp;显示系统内存及swap使用情况</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kettle使用介绍</title>
      <link href="/2018/09/28/Kettle%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/09/28/Kettle%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>介绍Kettle工具之前首先了解一下ETL技术：<br>ETL（Extract-Transform-Load），用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。</p><p>ETL是构建数据仓库的重要一环（不仅限于数据仓库），用户从数据源抽取出所需的数据，经过数据清洗和加工，最终按照预先定义好的模型，将数据加载到目的数据仓库中去，做各种商业智能分析或者用于主数据管理体系。 </p><p>数据抽取：将数据从各种原始的业务系统或者非结构化文档中读取出来。<br>数据转换：按照预先设计好的规则将抽取得数据进行转换、清洗、加工，统一抽取的数据格式。<br>数据装载：将转换完的数据按制定的规则增量或全部导入到目的数据仓库。 </p><ol><li><p>Kettle概念</p><p>Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。</p><p>Kettle 中文名称叫水壶，该项目的主程序员MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。</p><p>Kettle这个ETL工具集，它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，而不是你想怎么做。</p><p>Kettle中有两种脚本文件，转换（transformation）和作业（job），转换完成针对数据的基础转换，作业则完成整个工作流的控制。</p></li><li><p>下载和部署</p><p>Kettle下载地址：<a href="http://kettle.pentaho.org/" target="_blank" rel="noopener">http://kettle.pentaho.org/</a> 。</p><p><img src="./images/kettle_download.png" alt=""></p><p>压缩包下载完成后，因Kettle是绿色软件，解压到任意本地路径即可。</p></li><li><p>Kettle环境配置（Java运行环境配置，此步骤略）</p></li><li><p>Kettle转换中常用组件</p><ul><li><p>表输入（Table Input）：常用来利用连接和SQL，从数据库中读取信息。自动生成基本的SQL语句。</p><p>| 选项                | 描述                                                       |<br>| ——————- | ———————————————————- |<br>| 步骤名称            | 步骤的名称，在单一的步骤中，名称必需唯一                   |<br>| 数据库连接          | 读取数据的数据库连接                                       |<br>| SQL                 | SQL 语句用来从数据库连接中读取数据                         |<br>| 允许延迟加载        | 无                                                         |<br>| 替换SQL语句里的变量 | 替换SQL语句中的变量名                                      |<br>| 从步骤插入数据      | 指定我们期待读取数据的步骤名称。这些信息能被插入到 SQL语句 |<br>| 记录数限制          | 设置从数据库中读取的行数，0 所有行                         |</p></li><li><p>获取系统信息（GetSystem Info）：从 Kettle环境中获取信息。</p><p>| 选项     | 描述                                     |<br>| ——– | —————————————- |<br>| 步骤名称 | 步骤的名称，在单一的步骤中，名称必需唯一 |<br>| 名称     | 参数名称                                 |<br>| 类型     | 获取日期、转换信息、命令行参数等。       |</p></li><li><p>表输出（Table Output）：可以存储信息到数据库表中。</p><p>| 选项                     | 描述                                                         |<br>| ———————— | ———————————————————— |<br>| 步骤名称                 | 步骤的名称，在单一的步骤中，名称必需唯一                     |<br>| 数据库连接               | 用来写数据的数据库连接                                       |<br>| 目标模式                 | 要写数据的表的 Schema的名称。允许表名中包含“.”对数据源来说是很重要的。 |<br>| 目标表                   | 要写数据的表名                                               |<br>| 提交记录数量             | 在数据表中用事务插入行。如果 N比 0大，每 N行提交一次连接。否则，不使用事务，速度会慢一些。 |<br>| 裁剪表                   | 在插入数据之前清除目标表数据                                 |<br>| 忽略插入错误             | 使 Kettle忽略比喻违反主键约束之类的插入错误，18个警告将被日志记录。在批量插入的时候这个功能不可用。 |<br>| 使用批量插入             | 如果你想批量插入的话，就使用这个选项。这个选项的速度最快，默认被选上。 |<br>| 表分区数据               | 使用这个选项可以在多个表之间拆分数据。例如用把数据放到表 ALES_200510, SALES_200511，SALES_200512，…中来代替直接插入数据到表 SALES 中。 |<br>| 表名定义在一个字段里     | 使用这些选项可以拆分数据到一个或者多个表里，目标表名可以用你指定的字段来定义。例如如果你想存储顾客性别数据，这些数据可能会存储到表 M和表 F里面（female女性和 male男性表）。这个选项可以阻止这些字段插入到对应的表里。 |<br>| 返回一个自动产生的关键字 | 往表中插入行时，是否产生一个关键字                           |<br>| 自动产生关键字的字段名称 | 指定包含关键字的输出字段的字段名称                           |<br>| SQL                      | 根据源表表结构生成自动创建输出表的 SQL脚本                   |</p></li><li><p>字段选择（Select values）：选择字段、重命名字段、指定字段的长度或者精度。</p><p>下面是三个不同标签的功能：</p><p>选择和修改：指定需要流到输出流中的字段的精确顺序和名称</p><p>删除：指定必须从输出流中删除的字段</p><p>元数据：修改元数据字段的名称、类型、长度和精度</p><p>| 选项     | 描述                                     |<br>| ——– | —————————————- |<br>| 步骤名称 | 步骤的名称，在单一的步骤中，名称必需唯一 |<br>| 改名     | 如果不想改名，就使用空白                 |<br>| 长度     | 输入数字指定长度（-1：代表没有长度指定） |<br>| 精度     | 输入数字指定精度（-1：代表没有精度指定） |</p></li><li><p>过滤记录（Fileter rows）：允许你根据条件和比较符来过滤记录。一旦这个步骤连接到先前的步骤中，你可以简单的单击“<field>”“=”和“<value>”，区域来构建条件。</value></field></p><p>| 选项                    | 描述                                     |<br>| :———————- | —————————————- |<br>| 步骤名称                | 步骤的名称，在单一的步骤中，名称必需唯一 |<br>| 发送“true”数据给步骤：  | 指定条件返回 true的数据将发送到此步骤。  |<br>| 发送“false”数据给步骤： | 指定条件返回 false的数据将发送到此步骤。 |</p></li><li><p>执行SQL语句（ExecuteSQL script）：可以执行 SQL脚本。</p><p>| 选项       | 描述                                     |<br>| ———- | —————————————- |<br>| 步骤名称   | 步骤的名称，在单一的步骤中，名称必需唯一 |<br>| 执行每一行 | 步骤的每一个输入行执行                   |<br>| 变量替换   | 可以在 SQL脚本中使用参数                 |</p></li><li><p>设置变量（Set Variable）：允许你在一个任务中或者虚拟机中设置变量。它仅仅可以用一行数据来设置变量值。</p><p>下面是可以用的范围设定：</p><p>Valid in the virtual machine: 整个虚拟机将知道那个变量，仅可以在单机模式下运行。</p><p>Valid in the parent job: 变量仅在父任务中合法的。</p><p>Valid in the grand-parent job: 变量仅在祖父任务中合法的。</p><p>Valid in the root job:  变量仅在根任务中合法的。</p></li><li><p>获取变量（Get Variable）：允许你获取一个变量，它可以返回行或者附加值到输入行。</p><p>备注：你需要指定完整的变量格式${variable}或者%%variable%%。</p></li></ul></li><li><p>Kettle作业中常用组件</p><ul><li><p>开始（Start）：Start 是任务执行的入口，首先必须是任务可以执行。只有无条件的任务条目可以从Start入口连接。注：大家在开始过程当中最好只把它当成一个入口组件，不要使用它来做定时任务计划之类的工作，如果做定时任务有产生JAVA JVM内存溢出，这是一个BUG，在Kettle官网也说明不提倡使用此组件来做定时任务。</p></li><li><p>裁剪表（Truncate tables）：用来清空指定表中所有数据组件，类似与Oracle中Truncate语法。</p><p>| 选项                     | 描述                                     |<br>| ———————— | —————————————- |<br>| Job entry name           | 步骤的名称，在单一的步骤中，名称必需唯一 |<br>| 数据库连接               | 读取数据的数据库连接                     |<br>| Previous results to args | 通过上一步骤参数传递到此步骤使用         |<br>| Tables name              | 填写需要清空的表名                       |<br>| Schema name              | 表名的模式名                             |</p></li><li><p>转换（Transformation）：此转换组件是用来执行已经定义好的转换。</p><p>| 选项                                 | 描述                                                 |<br>| ———————————— | —————————————————- |<br>| Job名称                              | 任务条目的名称，在单个任务中，必须唯一               |<br>| 转换名称                             | 需要运行的转换的名称                                 |<br>| 资源库路径                           | 指定资源库目录中的文件名                             |<br>| 转换文件名                           | 如果你不是使用资源库工作，就指定转换运行的 XML文件名 |<br>| 指定文件日志                         | 检查是否为转换指定一个单独的日志文件                 |<br>| Apped logfile                        | 是否以追加的方式写入日志文件                         |<br>| 日志文件名                           | 日志文件的目录和名称                                 |<br>| 日志文件后缀名                       | 文件名扩展（例如：log或者 txt）                      |<br>| 日志文件包含日期                     | 文件名中添加系统日期                                 |<br>| 日志文件包含时间                     | 文件名中添加系统时间                                 |<br>| 日志级别                             | 日志级别                                             |<br>| 复制以前结果到参数                   | 复制以前结果到参数                                   |<br>| Copy previous  results to parameters | 上一次的转换结果复制到参数中                         |<br>| 执行每一行输入行                     | 支持循环，根据参数结果集执行每一行参数               |<br>| 在执行之前清除结果行列表             | 在转换运行之前，检查确保列表或结果行已经被清除       |<br>| 在执行之前清除结果文件列表           | 在转换运行之前，检查确保列表或结果文件已经被清除     |<br>| 在集群模式下运行这个转换             | 是否使用集群模式运行转换                             |<br>| Remote save  server                  | 执行集群节点服务器                                   |</p></li><li><p>执行SQL脚本（Execute SQL scripts）：使用 SQL任务条目执行 SQL 脚本，多行脚本之前用“;”隔开。</p><p>| 选项           | 描述                                   |<br>| ————– | ————————————– |<br>| 作业项名称     | 任务条目的名称，在单个任务中，必须唯一 |<br>| 数据库连接     | 数据库连接名称                         |<br>| 从文件中得到的 | 是否指定以文件形式执行SQL              |<br>| SQL文件名      | 指定SQL文件完整路径                    |<br>| 使用变量替换   | 如果SQL脚本中有使用到变量需要勾选      |<br>| SQL脚本        | 要执行的 SQL 脚本                      |</p></li><li><p>作业（Job）：此作业组件是用来执行已经定义好的作业，切勿设计死循环。</p><p>| 选项                                 | 描述                                                 |<br>| ———————————— | —————————————————- |<br>| 作业项名称                           | 作业名称，在单个任务中，必须唯一                     |<br>| 作业名称                             | 需要运行的作业的名称                                 |<br>| 资源库路径                           | 指定资源库目录中的文件名                             |<br>| 作业文件名                           | 如果你不是使用资源库工作，就指定作业运行的 XML文件名 |<br>| 指定文件日志                         | 检查是否为转换指定一个单独的日志文件                 |<br>| Apped logfile                        | 是否以追加的方式写入日志文件                         |<br>| 日志文件名                           | 日志文件的目录和名称                                 |<br>| 日志文件后缀名                       | 文件名扩展（例如：log或者 txt）                      |<br>| 日志文件包含日期                     | 文件名中添加系统日期                                 |<br>| 日志文件包含时间                     | 文件名中添加系统时间                                 |<br>| 日志级别                             | 日志级别                                             |<br>| 将上一结果作为参数                   | 上一次结果作为参数使用                               |<br>| Copy previous  results to parameters | 上一次的转换结果复制到参数中                         |<br>| 执行每一行输入行                     | 支持循环，根据参数结果集执行每一行参数               |<br>| Remote save  server                  | 执行集群节点服务器                                   |</p></li><li><p>成功（Success）：此组件用来标识当前作业执行状态，在一个作业中可以有0个或者多个“Success”组件。</p></li><li><p>邮件（Mail）：可以使用 Mail任务条目来发送 e-Mail。</p><p>| 选项               | 描述                                 |<br>| :—————– | ———————————— |<br>| 地址标签           |                                      |<br>| 邮件作业名称       | 邮件作业名称，在单个任务中，必须唯一 |<br>| 目的地址           | 填写需要发送指定的邮箱地址           |<br>| 抄送               | 需要抄送人邮箱地址                   |<br>| 暗送               | 需要暗送人邮箱地址                   |<br>| 回复名称           | 邮件回复名称                         |<br>| 回复地址           | 邮件回复地址                         |<br>| Reply to           | 回复                                 |<br>| 联系人             | 在发送邮件内容中显示联系人           |<br>| 联系电话           | 在发送邮件内容中显示联系人电话       |<br>| 服务器标签         |                                      |<br>| SMTP服务器         | SMTP服务器，如163（smtp.163.com）    |<br>| 端口               | 端口，则是SMTP服务器，如163（25）    |<br>| 用户验证           | 是否需要用户验证                     |<br>| 用户名             | RotKang                              |<br>| 密码               | RotKang                              |<br>| 使用安全证         | 是否需要安全验证                     |<br>| 安全连接类型       | 默认为SSL                            |<br>| 邮件消息标签       |                                      |<br>| 信息里带日期       | 在邮箱内容中显示服务器日期           |<br>| 只发邮件注释       | 在发送邮件内容里只显示注释里的内容   |<br>| 使用HTML邮件格     | 使用HTML邮件格，目前测试不准确       |<br>| 编码               | 字符集编码                           |<br>| 管理优先级         | 默认                                 |<br>| 优先级             | 默认                                 |<br>| 重要               | 默认                                 |<br>| 主题               | 邮件主题名称                         |<br>| 注释               | 邮件内容说明                         |<br>| 附件标签           |                                      |<br>| 带附件             | 目前测试有问题，勾选无               |<br>| 文件类型           | 目前测试有问题                       |<br>| 压缩成文件统一格式 | 目前测试有问题                       |<br>| 压缩文件名称       | 目前测试有问题                       |</p></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> kettle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ETL利器 </tag>
            
            <tag> 跨平台 </tag>
            
            <tag> JAVA编写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建线程池的四种方式</title>
      <link href="/2018/09/05/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/09/05/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Java可通过Executors提供四种线程池，分别为：</p><ul><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><p>newCachedThreadPool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        final int index = i;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cachedThreadPool.execute(new Runnable() &#123;</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               System.out.println(index);</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这里的线程池是无限大的，当一个线程完成任务之后，这个线程可以接下来完成将要分配的任务，而不是创建一个新的线程。</p><p>newFixedThreadPool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        final int index = i;</span><br><span class="line">        fixedThreadPool.execute(new Runnable() &#123;</span><br><span class="line">           public void run() &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">              System.out.println(index);</span><br><span class="line">                     Thread.sleep(10);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。</p><p>newScheduledThreadPool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        scheduledThreadPool.schedule(new Runnable() &#123;</span><br><span class="line">           public void run() &#123;</span><br><span class="line">              System.out.println(&quot;delay 3 seconds&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, 3, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        final int index = i;</span><br><span class="line">        singleThreadExecutor.execute(new Runnable() &#123;</span><br><span class="line">           public void run() &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">              System.out.println(index);</span><br><span class="line">                     Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按顺序执行线程任务，但不同于单线程，这个线程池只能存在一个线程，这个线程死后另外一个线程会补上 。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式的四类写法</title>
      <link href="/2018/08/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%86%99%E6%B3%95/"/>
      <url>/2018/08/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul><li><p>饱汉模式（也称懒汉）</p><ol><li><p>饱汉-基础（非线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饱汉模式的核心是懒加载。优点是启动速度快、节省资源，一直到实例被第一次访问才初始化单例；缺点是线程不安全，if语句存在竞态条件。在单线程环境下可采用此种写法。</p></li><li><p>饱汉-变种1（线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然绝对线程安全，但是并发性能极差，单例只需要初始化一次，但初始化后，synchronized的锁无法避免，从而getInstance()方法完全变成了串行操作。在性能不敏感的场景下可采用这种写法。</p></li><li><p>饱汉-变种2（非线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">        synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的核心是双重检查锁（Double Check Lock，简称DCL），代码看起来似乎是线程安全，实则不然，由于指令重排序，可能得到“半个对象”，关于指令重排序，读者可自行学习。</p></li><li><p>饱汉-变种3（线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">        synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法专门针对变种2，在instance上增加了volatile关键字，使用于性能敏感的场景。</p></li></ol></li><li><p>饿汉模式（线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式的好处是天生的线程安全（类加载时初始化单例），使用时没有延迟；坏处是可能造成资源浪费（也即是在类加载后一直不使用单例）。</p></li><li><p>Holder模式（线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line">        private SingletonHolder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Holder模式满足了两点要求：核心仍是静态变量，满足线程安全；通过静态内部类持有真正实例，间接实现了懒加载，略优于饱汉模式的变种3。</p></li><li><p>枚举模式（线程安全）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然牺牲了静态工厂方法的优点（无法实现懒加载），但它可以避免多线程同步问题，还能防止反序列化重新创建新的对象。</p></li></ul><p>以上分析忽略了反射和序列化可以创建新的实例从而破坏单例模式的问题，只有枚举模式能防范这一问题。下面对以上分析做个总结：</p><table><thead><tr><th style="text-align:center">实现方式</th><th style="text-align:center">核心点</th><th style="text-align:center">资源浪费</th><th style="text-align:center">线程安全</th><th style="text-align:center">多线程环境下的性能优化</th></tr></thead><tbody><tr><td style="text-align:center">饱汉-基础</td><td style="text-align:center">懒加载</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">饱汉-变种1</td><td style="text-align:center">懒加载、同步</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">饱汉-变种2</td><td style="text-align:center">懒加载、DCL</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">饱汉-变种3</td><td style="text-align:center">懒加载、DCL、volatile</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">饿汉模式</td><td style="text-align:center">静态变量初始化</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">Holder模式</td><td style="text-align:center">静态变量初始化、Holder</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">枚举模式</td><td style="text-align:center">枚举本质、静态变量初始化</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 单例 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java代码优化（下）</title>
      <link href="/2018/08/27/Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2018/08/27/Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<ol start="24"><li><p>使用数据库连接池和线程池</p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p></li><li><p>使用带缓冲的输入输出流进行IO操作</p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。</p></li><li><p>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</p><p>这个需要理解ArrayList和LinkedList的原理。</p></li><li><p>避免让public方法中有太多的形参</p><p>public方法即对外提供的方法，如果这些方法有太多形参主要有两点坏处：</p><ul><li>违反面向对象的编程思想，Java讲究一切都是对象，太多形参和面向对象的编程思想不契合</li><li>参数太多势必导致方法调用的出错率增加</li></ul><p>参数最好控制在两个以内，比如我们用jdbc写一个insertStudent方法，有10个学生信息字段需要插入Student表中，可以把这10个参数封装在一个实体类中，作为insertStudent方法的形参。</p></li><li><p>字符串变量和字符串常量equals的时候将字符串常量写在前面</p><p>这个技巧比较常见，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">if (str.equals(&quot;123&quot;)) &#123;</span><br><span class="line">code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">if (&quot;123&quot;.equals(str)) &#123;</span><br><span class="line">code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做主要可以避免空指针异常。</p></li><li><p>在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</p></li><li><p>不要对数组使用toString()方法</p><p>看一下对数组使用toString()打印出来的是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = new int[] &#123;1, 2, 3&#125;;</span><br><span class="line">    System.out.println(arr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@18a992f</span><br></pre></td></tr></table></figure><p>本意是想打印出数组内容，但却可能因为数组引用arr为空而导致空指针异常。不过虽然对数组使用toString()方法没有意义，但是对集合使用该方法可以打印出集合里面的内容的，因为集合的父类AbstractCollections<e>重写了Object的toString()方法。</e></p></li><li><p>不要对超出范围的基本数据类型做向下强制转型</p><p>例如一下代码不会得到想要的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    long l = 12345678901234L;</span><br><span class="line">    int i = (int) l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能期望得到其中的某几位，但结果却是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1942892530</span><br></pre></td></tr></table></figure><p>解释一下，在Java中long型数据是8个字节64位，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据时4个字节32位，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，也就是我们上面控制台的输出内容。</p><p>注：整型默认的数据类型为int，浮点型默认的数据类型为double。</p></li><li><p>公用的集合类中不使用的数据要及时remove掉</p></li><li><p>把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式，String.valueOf(数据)次之，数据+””最慢</p><ul><li>String.valueOf()方法底层调用了Integer.toString()方法，但在调用前会做空判断</li><li>Integer.toString()方法直接调用</li><li>数据 + “”的底层使用了StringBuilder实现，先用append()方法进行拼接，再用toString()方法获取字符串</li></ul></li><li><p>使用最有效率的方式去遍历Map</p><p>遍历Map的方式有很多，通常情景下我们需要的是遍历Map中的Key和value，以下推荐使用的效率最高的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(&quot;111&quot;, &quot;222&quot;);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">        Sysout.out.println(entry.getKey() + &quot;\t&quot; + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是遍历这个Map的key值，则用”Set<string> keySet = map.keySet();”会比较合适。</string></p></li><li><p>对资源的close()建议分开操作</p><p>比如有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然麻烦点，却能避免资源泄露，试想，如果用没有修改过的代码，万一XXX.close()抛异常了，那么就进入catch块中了，YYY.close()则不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，可能引起资源句柄泄漏。而改为修改过的代码，就保证了无论如何XXX和YYY都会被close掉。</p></li><li><p>切忌以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定</p></li><li><p>long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个细节需要注意</p></li><li><p>所有重写的方法必须保留@Override注解</p><p>这么做有三点原因：</p><ul><li>清楚地知道这个方法由父类继承而来</li><li>getObject()和get0bject()方法，前者第四个字母是”O”，后者第四个字母是”0”，加了@Override注解可以马上判断是否重写成功</li><li>在抽象类中对方法签名进行修改，实现类会马上报出编译错误</li></ul></li><li><p>推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)有空指针异常的风险</p></li><li><p>循环体内不要使用“+”进行字符串的拼接，而直接使用StringBuilder不断append</p><p>每次虚拟机碰到“+”这个操作符对字符串进行拼接的时候，会new出一个StringBuilder，然后调用append方法，最后调用toString方法转换为字符串，也就是循环多少次，就会new出多少个StringBuilder来，这对于内存来讲是一种浪费。</p></li><li><p>不捕获Java类库中定义的继承自RuntimeException的运行时异常类</p><p>异常处理效率较低，RuntimeException的运行时异常，其中绝大多数完全可由程序员来规避，比如：</p><ul><li>ArithmeticException            可通过判断除数是否为空来规避</li><li>NullPointerException           可通过判断对象是否为空来规避</li><li>IndexOutOfBoundsException    可通过判断数组/字符串长度来规避</li><li>ClassCastException               可通过instanceof关键字来规避</li><li>ConcurrentModificationException         可使用迭代器来规避</li></ul></li><li><p>避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致性能下降，JDK7之后可以使用ThreadLocalRandom来获取随机数</p></li><li><p>静态类、单例类、工厂类将它们的构造函数置为private</p><p>这是因为静态类、单例类、工厂类这种类本来就不需要我们从外部将它们new出来，将构造函数置为private之后，保证了这些类不会产生实例。</p></li><li><p>对于TreadLocal使用前或者使用后一定要先remove</p><p>线程池技术做的是一个线程重用，意味着，在代码运行过程中，一条线程使用完毕，并不会销毁而是等待下一次的使用，在Thread类中，持有ThreadLocal.ThreadLocalMap的引用，线程不销毁意味着上条线程set的ThreadLocal.ThreadLocalMap中的数据依然存在，那么在下一条线程重用这个Thread的时候，很可能get到的是上条线程set的数据而不是自己想要的内容。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java代码优化（上）</title>
      <link href="/2018/08/23/Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2018/08/23/Java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>代码优化的定义：在不改变程序运行效果的前提下，对被编译的程序进行等价变换，使之能生成更加高效的目标代码。等价的含义是使得变换后的代码运行结果与变换前代码运行结果相同。优化的含义是最终生成的目标代码短（运行时间更短、占用空间更小），时空效率优化。</p><p>代码优化的作用：避免未知的错误。在写代码的时候，从源头开始注意各种细节，权衡并使用最优的选择，将会在很大程度上避免出现未知的错误，从长远来看也能极大地降低工作量。</p><p>代码优化的目标：为了减小代码的体积，并提高代码的运行效率。</p><ol><li><p>尽量指定类、方法的final修饰符</p><p>为类指定final修饰符，则该类不可被继承；为方法指定final修饰符，则该方法不可被重写。如果指定了一个类为final，则该类所有的方法都是final的，Java编译器会寻找机会内联所有的final方法，而内联对于提升Java运行效率的作用极大，此举能使性能平均提升50%。</p></li><li><p>尽量重用对象</p><p>尤其是对String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替，由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p></li><li><p>尽可能使用局部变量</p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p></li><li><p>及时关闭流</p><p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p></li><li><p>尽量减少对变量的重复计算</p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。例如下面的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i ++) &#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0, length = list.size(); i &lt; length; i ++) &#123;</span><br><span class="line">code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在list.size()很大时，就减少了很多的消耗。</p></li><li><p>尽量采用懒加载的策略，即在需要的时候才创建</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;aaa&quot;;</span><br><span class="line">if (i == 1) &#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (i == 1) &#123;</span><br><span class="line">    String str = &quot;aaa&quot;;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>慎用异常</p><p>异常对性能不利，抛出异常时首先需要创建一个新的对象，Throwable接口的构造函数调用名为fillnStackTrace()的本地同步方法，fillnStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p></li><li><p>不要在循环中使用try…catch…，应该把其放在最外层（有待商榷）</p></li><li><p>如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</p><p>比如ArrayList、LinkedList、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：StringBuilder() （默认分配16个字符的空间）、StringBuilder(int size) （默认分配size个字符的空间）、StringBuilder(String str) （默认分配16个字符+str.length()个字符空间）</p><p>通过类的构造函数来设定它的初始化容量，可以明显提升性能。拿StringBuilder来说，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的两倍再加2，即无论何时只要StringBuilder达到它的最大容量时，它不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中，这样的操作十分耗费性能。既浪费了内存空间还降低了代码运行效率。</p><p>因此，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的。但是，像HashMap这种以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0，初始大小建议设置为2的N次幂。</p></li><li><p>当复制大量数据时，使用System.arraycopy()命令</p></li><li><p>乘法和除法使用移位操作</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (val = 0; val &lt; 100000; val += 5) &#123;</span><br><span class="line">    a = val * 8;</span><br><span class="line">    b = val / 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便的、最快的，因此建议修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (val = 0; val &lt; 100000; val += 5) &#123;</span><br><span class="line">    a = val &lt;&lt; 3;</span><br><span class="line">    b = val &gt;&gt; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移位操作虽然效率高，可能会使代码不太好理解，因此最好加上相应的注释。</p></li><li><p>循环内不要不断创建对象引用</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt;= count; i ++) &#123;</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存，建议改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = null;</span><br><span class="line">for (int i = 0; i &lt;= count; i ++) &#123;</span><br><span class="line">    obj = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，内存中只有一份Object对象引用，每次new Objct()的时候，Objct对象引用会指向不同的Object，但是内存中只有一份，这样可以大大节省内存空间。</p></li><li><p>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</p></li><li><p>尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后者由于使用了同步机制而增加了性能开销。</p></li><li><p>不要将数组声明为public static final</p><p>这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类改变。</p></li><li><p>尽量在合适的场合使用单例</p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要使用于以下三个方面：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问</li><li>控制实例的产生，以达到节约资源的目的</li><li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li></ul></li><li><p>尽量避免使用静态变量</p><p>当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    private static B b = new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。</p></li><li><p>及时清除不再需要的会话</p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须先被序列化，在大规模集群中，对对象进行序列化的代价非常昂贵。因此，当会话不再需要时，应及时调用HttpSession的invalidate()方法清除会话。</p></li><li><p>实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环，而不是foreach循环来遍历</p><p>JDK API对于RandomAccess接口的解释为：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通的for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用iterator效率会更高。可使用类似如下代码判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (list instanceof RandomAccess) &#123;</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i ++) &#123;&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环的底层实现原理就是迭代器Iterator，因此，如果是顺序访问那些类实例，则可使用foreach循环去遍历。</p></li><li><p>使用同步代码块替代同步方法</p><p>除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，从而影响了代码执行效率。</p></li><li><p>将常量声明为static final，并以大写命名</p><p>这样在编译器就可以把这些内容放入常量池中，避免运行期间计算生成常量的值，另外，将常量的名字以大写命名也能方便的区分出常量与变量。</p></li><li><p>不要创建一些不使用的对象，不要导入一些不使用的类</p></li><li><p>程序运行过程中避免使用反射</p><p>反射是Java提供给用户的一个强大功能，功能强大往往意味着效率不高，不建议在程序运行过程中频繁使用反射机制，尤其是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动时通过反射实例化一个对象并放入内存，用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动需要花多长时间。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java的位运算总结</title>
      <link href="/2018/08/23/Java%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/23/Java%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Java提供的位运算符有：左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）、位与（&amp;）、位或（|）、位非（~）、位异或（^），除了位非（~）是一元操作符外，其他的都是二元操作符。</p><ol><li><p>左移（&lt;&lt;）</p><p>例如：将5左移2位</p><p>程序会先将5转换为2进制表示形式（java中整数的默认类型为int，即32位）</p><p>5的二进制原码为：    0000 0000 0000 0000 0000 0000 0000 0101        左移2位后，低位补0</p><p>5左移2位的结果为：    0000 0000 0000 0000 0000 0000 0001 0100        换算成10进制为20</p><p>左移：对于正数或者负数左移，低位都是用0补</p></li><li><p>右移（&gt;&gt;）</p><p>例如：将5右移2位</p><p>程序会先将5转换为2进制表示形式</p><p>5的二进制原码为：    0000 0000 0000 0000 0000 0000 0000 0101        右移2位后，高位补0</p><p>5右移2位的结果为：    0000 0000 0000 0000 0000 0000 0000 0001        换算成10进制为1</p><p>右移：对于正数右移，高位用0补，对于负数右移，高位用1补</p></li><li><p>无符号右移（&gt;&gt;&gt;）</p><p>例如：将-5无符号右移3位</p><p>5的二进制原码为：    0000 0000 0000 0000 0000 0000 0000 0101</p><p>5的二进制反码为：    1111 1111 1111 1111 1111 1111 1111 1010</p><p>5的二进制补码为：    1111 1111 1111 1111 1111 1111 1111 1011        即为-5的二进制码</p><p>那么-5无符号右移3位的结果为536870911换算成二进制：0001 1111 1111 1111 1111 1111 1111 1111</p><p>在计算机中，负数以其正值的补码形式表示，对于负数，求其补码的方法为：在原码基础上，先置最高的符号位为1，剩下的位按位取反，末尾加1</p><p>无符号右移：对于负数无符号右移，高位用0补，自然负数变成正数</p></li><li><p>位与（&amp;）</p><p>例如：将5和3作与运算</p><p>5的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0101</p><p>3的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0011</p><p>5 &amp; 3的结果为1换算成二进制：  0000 0000 0000 0000 0000 0000 0000 0001</p><p>位与操作：第一个操作数的第n位与第二个操作数的第n位如果都是1，那么结果的第n位也为1，否则为0</p></li><li><p>位或（|）</p><p>例如：将5和3作或运算</p><p>5的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0101</p><p>3的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0011</p><p>5 | 3的结果为7换算成二进制：   0000 0000 0000 0000 0000 0000 0000 0111</p><p>位或操作：第一个操作数的第n位与第二个操作数的第n位只要有一个为1，那么结果的第n位为1，否则为0</p></li><li><p>位异或（^）</p><p>例如：将5和3作异或运算</p><p>5的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0101</p><p>3的二进制码为：                0000 0000 0000 0000 0000 0000 0000 0011</p><p>5 ^ 3的结果为6换算成二进制：   0000 0000 0000 0000 0000 0000 0000 0110</p><p>位异或操作：第一个操作数的第n位与第二个操作数的第n位如果相反，那么结果的第n位为1，否则为0</p></li><li><p>位非（~）</p><p>例如：将5作非运算</p><p>5的二进制码为：0000 0000 0000 0000 0000 0000 0000 0101</p><p>~ 5的结果为-6换算成二进制：    1111 1111 1111 1111 1111 1111 1111 1010</p><p>位非操作：位非是一元操作符，操作数的第n位为1，那么结果的第n位为0，反之为1</p></li></ol><p>由位运算操作符衍生而来的有：&amp;=（按位与赋值）、|=（按位或赋值 ）、^=（按位非赋值 ）、&gt;&gt;=（右移赋值 ）、&gt;&gt;&gt;=（无符号右移赋值 ）、&lt;&lt;=（赋值左移 ）</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java后端书架</title>
      <link href="/2018/08/21/Java%E5%90%8E%E7%AB%AF%E4%B9%A6%E6%9E%B6/"/>
      <url>/2018/08/21/Java%E5%90%8E%E7%AB%AF%E4%B9%A6%E6%9E%B6/</url>
      <content type="html"><![CDATA[<ol><li><p>操作系统与网络的书</p><p><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="noopener">《Linux内核设计与实现 第三版》</a></p><p><a href="https://book.douban.com/subject/25828773/" target="_blank" rel="noopener">《Linux系统编程 第二版》</a></p><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">《TCP/IP详解 卷1：协议》</a></p><p><a href="https://book.douban.com/subject/26268767/" target="_blank" rel="noopener">《WireShark网络分析就这么简单》</a></p><p><a href="https://book.douban.com/subject/26710788/" target="_blank" rel="noopener">《WireShark网络分析的艺术》</a></p></li><li><p>算法的书</p><p><a href="https://book.douban.com/subject/26745780/" target="_blank" rel="noopener">《数据结构与算法分析-Java语言描述 第三版》</a></p><p><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a></p></li><li><p>语言的书</p><p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a></p><p><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a></p><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机 第二版》</a></p><p><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a></p><p><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java核心技术-Core Java》</a></p></li><li><p>具体技能的书</p><p><a href="https://book.douban.com/subject/26593175/" target="_blank" rel="noopener">《Docker：容器与容器云》</a></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现分析》</a></p><p><a href="https://book.douban.com/subject/26702824/" target="_blank" rel="noopener">《分布式服务框架：原理与实践》</a></p><p><a href="https://book.douban.com/subject/26649141/" target="_blank" rel="noopener">《Spark技术内幕》</a></p><p><a href="https://book.douban.com/subject/26373138/" target="_blank" rel="noopener">《Netty权威指南 第二版》</a></p></li><li><p>程序员的自我修养</p><p><a href="https://book.douban.com/subject/1152111/" target="_blank" rel="noopener">《程序员修炼之道-从小工到专家》</a></p><p><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a></p><p><a href="https://book.douban.com/subject/11614538/" target="_blank" rel="noopener">《程序员的职业素养》</a></p><p><a href="https://book.douban.com/subject/1173730/" target="_blank" rel="noopener">《重构在册》</a></p><p><a href="https://book.douban.com/subject/4037534/" target="_blank" rel="noopener">《敏捷开发的艺术》</a></p></li><li><p>架构设计的书</p><p><a href="https://book.douban.com/subject/26304417/" target="_blank" rel="noopener">《发布！软件的设计与部署-Release It!:Design and Deploy Production-Ready Software》</a></p><p><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></p><p><a href="https://book.douban.com/subject/10756899/" target="_blank" rel="noopener">《高扩展性网站的50条原则》</a></p><p><a href="https://book.douban.com/subject/26772677/" target="_blank" rel="noopener">《微服务设计》</a></p><p><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></p></li></ol>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向切面的Spring—面向切面编程</title>
      <link href="/2018/08/16/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84Spring%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/08/16/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84Spring%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但往往会直接嵌入到应用的业务逻辑之中）。而把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题。</p><p>DI有助于应用对象之间的解耦，而AOP则可以实现横切关注点与它们所影响的对象之间的解耦。</p><p>横切关注点可以被模块化为特殊的类，这些类被称为切面。换言之，切面可以实现横切关注点（跨多个应用对象的逻辑）的模块化。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p><p>描述切面的常用术语有通知、切点和连接点：</p><ul><li><p>通知（Advice）</p><p>Spring的切面可以应用五种类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li></ul></li><li><p>连接点（Join point）</p><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为</p></li><li><p>切点（Pointcut）</p><p>一个切面并不需要通知应用的所有连接点，切点的定义会匹配通知所要织入的一个或多个连接点，由此看来，切点是有助于缩小切面所通知的连接点的范围</p></li><li><p>切面（Aspect）</p><p>切面是通知和切点的结合，通知和切点共同定义了切面的全部内容—它是什么，在何时何处完成其功能</p></li><li><p>引入（Introduction）</p><p>引入允许我们向现有的类添加新方法或属性</p></li><li><p>织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入，AspecJ的织入编译器是以这种方式织入切面的</li><li>类加载期：切面在目标类加载到JVM时被织入，AspecJ5的加载时织入支持这种方式</li><li>运行期：切面在应用运行的某个时刻被织入，一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象，Spring AOP是以这种方式织入切面的</li></ul></li></ul><p>创建切点来定义切面所织入的连接点是AOP框架的基本功能。</p><p>Spring提供了四种类型的AOP支持：</p><ul><li>基于代理的经典Spring AOP</li><li>纯POJO切面</li><li>@AspectJ注解驱动的切面</li><li>注入式AspectJ切面</li></ul><p>Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。此处对代理以及静态代理与动态代理之间的区别作一下讲解：</p><ul><li>代理：代理是一种常见的设计模式，它的目的是为其他对象提供一个代理来控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。通俗来讲，代理所要解决的问题是当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还能让我们完成与另一个类之间的关系的统一管理，但是，代理类与委托类必须实现相同的接口，因为代理真正调用的还是委托类的方法。</li><li>静态代理与动态代理：静态代理类只能为特定的接口服务，一个代理只能代理一种类型，而且是在编译时就已经确定被代理的对象，要想为多个接口服务则需要建立很多个代理类。而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。</li></ul><p>如果说AOP是一种思想，那么动态代理可以说是AOP思想的一种实现。</p><p>Spring的切面由包裹了目标对象的代理类实现，代理类用于处理方法的调用，执行额外的切面逻辑以及调用目标方法。只有当应用需要被代理的bean时，Spring才创建代理对象。</p><p>也正是因为Spring基于动态代理，所以Spring只支持方法连接点。而一些其他的AOP框架，如AspectJ和JBoss，除了方法切点，它们还提供字段和构造器接入点。由于Spring缺少对字段连接点的支持，我们无法创建细粒度的通知，例如拦截对象字段的修改。但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，我们可以利用AspectJ来补充Spring AOP的功能。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 面向切面 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring之旅—简化Java开发</title>
      <link href="/2018/08/13/Spring%E4%B9%8B%E6%97%85%E2%80%94%E7%AE%80%E5%8C%96Java%E5%BC%80%E5%8F%91/"/>
      <url>/2018/08/13/Spring%E4%B9%8B%E6%97%85%E2%80%94%E7%AE%80%E5%8C%96Java%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>虽然Spring用bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须遵循JavaBean规范，一个Spring组件可以是任何形式的POJO，此处采用JavaBean的广泛定义，即POJO的同义词。</p><p>为了降低java开发的复杂性，Spring采取了以下四种关键性策略：</p><ul><li>基于POJO的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ul><h5 id="1-激发POJO的潜能"><a href="#1-激发POJO的潜能" class="headerlink" title="1. 激发POJO的潜能"></a>1. 激发POJO的潜能</h5><p>Spring不会强迫你实现Spring规范的接口或继承Spring规范的类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明你使用了Spring。最坏的场景是，一个类或许会使用Spring注解，但它依旧是POJO。Spring的非侵入式编程意味着这个类在Spring应用和非Spring应用中都可以发挥同样的作用。</p><h5 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h5><p>任何一个有实际意义的应用都会由两个或者更多的类组成，这些类相互之间进行协作来完成特定的业务逻辑。传统的做法，每个对象负责管理与自己相互协作的对象的引用，会导致高度耦合和难以测试的代码。</p><p>耦合的两面性：一方面，紧密耦合的代码难以测试，难以复用，难以理解，并表现出“打地鼠”式的bug特性；另一方面，一定程度的耦合也是必须的，因为完全没有耦合的代码什么也做不了。</p><p>通过DI（dependency injection, 依赖注入）,对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系会被自动注入到需要它们的对象中去。</p><p>依赖注入的方式之一，构造器注入。</p><p>DI所带来的最大收益，松耦合。</p><p>创建应用组件之间协作的行为通常称为装配。采用XML是Spring中很常见的一种装配bean的方式。</p><p>Spring通过应用上下文（Application Context）装配bean的定义并把他们组装起来，Spring应用上下文全权负责对象的创建和组装。</p><h5 id="3-应用切面"><a href="#3-应用切面" class="headerlink" title="3. 应用切面"></a>3. 应用切面</h5><p>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-oriented programming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p><p>诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。而AOP能使这些系统服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去，所造成的结果就是这些组件会有更高的内聚性并且更加关注自身的业务。总之，AOP能确保POJO的简单性。</p><p>借助AOP，可以使用各种功能层去包裹核心业务层，这些层以声明的方式灵活地应用的系统中，你的核心应用甚至根本不知道它们的存在。是将安全、事务以及日志关注点与核心业务逻辑相分离。</p><p>AOP的简单流程：声明bean、声明切面、定义切点、声明前置通知、声明后置通知。</p><h5 id="4-使用模板消除样板式代码"><a href="#4-使用模板消除样板式代码" class="headerlink" title="4. 使用模板消除样板式代码"></a>4. 使用模板消除样板式代码</h5><p>JDBC不是产生样板式代码的唯一场景，JMS、JNDI和使用REST服务通常也涉及大量的重复代码。Spring旨在通过模板封装来消除样板式代码，于是有了Spring的JdbcTemplate。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 面向切面 </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring之旅—前言</title>
      <link href="/2018/08/09/Spring%E4%B9%8B%E6%97%85%E2%80%94%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/09/Spring%E4%B9%8B%E6%97%85%E2%80%94%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>在诞生之初，创建Spring的主要目的是用来替代更加重量级的企业级Java技术，尤其是EJB（Enterprise JavaBean）。相对于EJB来说，Spring提供了更加轻量级和简单的编程模型。它增强了简单老式Java对象POJO（Plain Old Java Object）的功能，使其具备了之前只有EJB和其他企业级Java规范才具有的功能。此处对EJB、POJO以及JavaBean的定义及区别作一下介绍：</p><ul><li><p>EJB：一组“功能”JavaBean的集合，这一组JavaBean组合起来实现了某个企业组的业务逻辑，这里的一组JavaBean不是随意组合的，它们需要满足能实现某项业务功能的搭配。使用EJB，需要使用JavaEE服务器，EJB是大型的。</p></li><li><p>POJO：有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口，没有从任何类继承、也没实现任何接口，更没有被其他框架侵入的java对象。</p></li><li><p>JavaBean：一种java语言编写的可重用组件，符合一定规范的java类，不是一种技术，而是一种规范。它的方法命名，构造及行为必须符合特定的约定：</p><ol><li>所有属性为private</li><li>这个类必须有一个公共的缺省构造函数，即无参构造器</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范</li><li>这个类是可序列化的，即实现serializable接口</li></ol></li></ul><p>POJO的格式是用于数据的临时传递，它只能装载数据，作为数据传递的载体，不具备业务逻辑处理的能力，而JavaBean虽然数据的获取与POJO一样，但是JavaBean中往往会封装一些简单逻辑。</p><p>Spring正在涉足和创新的领域：移动开发、社交API集成、NoSQL数据库、云计算以及大数据。</p>]]></content>
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
